#
# Logfile::Config::Tivoli.pm - Tivoli Config Module
#
# Purpose: Provide a convenient way for loading
#          tivoli config files and
#          return it as hash structure
#
package Nagios::Tivoli::Config::Logfile;


use strict;
use warnings;
use Carp;

sub new {
    # create new object
    my($this, $param ) = @_;
    my $class = ref($this) || $this;

    # default options and definition with options are allowed
    my $self = {
        'formatfile'   => '',  # format file with tivoli format definitions, can be an array of files

        'formatstring' => '',  # format file content as string

        # mapping tivoli severities to nagios exit codes
        'tivoli_mapping' => {
            'fatal'      => 2,
            'critical'   => 2,
            'severe'     => 2,
            'warning'    => 1,
            'minor'      => 1,
            'harmless'   => 0,
            'unknown'    => 0,
        },
    };

    # create the class instance
    bless $self, $class;

    # parse parameter
    if(ref($param) eq "HASH") {
        for my $key (keys %{$param}) {
            if(!defined $self->{lc $key}) {
                carp("unrecognized parameter: $key");
            } else {
                if(ref($param->{$key}) eq 'HASH') {
                    $self->_mergeHash($self->{$key}, $param->{$key});
                } else {
                    $self->{lc $key} = $param->{$key};
                }
            }
        }
    }
    elsif(ref($param) eq "") {
        $self->{"formatfile"} = $param;
    } else {
        croak("formatfile is a required parameter");
    }

    if(    (!defined $self->{'formatfile'}   or $self->{'formatfile'}   eq '')
       and (!defined $self->{'formatstring'} or $self->{'formatstring'} eq '')) {
        croak("please either specify formatfile or formatstring");
    }

    if(defined $self->{'formatstring'} and $self->{'formatstring'} ne '') {
        $self->{'_formatstring'} = $self->{"formatstring"};
    } else {
        $self->{'_formatstring'} = $self->_read($self->{"formatfile"});
    }
    my $rt = $self->_parse;
printf "i parsed %s\n", 
    Data::Dumper::Dumper($self->{formats});
    if($rt != 0) {
        croak("parsing failed, see previous messages...");
        return undef;
    }

    return $self;
}

sub set_format_mappings {
    my $self = shift;
    my %mappings = @_;
    $self->{format_mappings} = \%mappings;
}

##############################################
# check if a logfile line matches any given pattern
sub match {
    my $self = shift;
    my $line = shift;
    foreach my $format (reverse @{$self->{'formats'}}) {
        next if !defined $format->{'slots'};
        next if !defined $format->{'slots'}->{'severity'};
	next if $format->{'format_name'} eq '*DISCARD*';

        my @matches;
        print "\n----------------------------------\n";
        print $format->{'format_name'}."\n";
        print "line: ".$line."\n";
        print "pattern: ".$format->{'pattern'}."\n";
        if (@matches = $line =~ /$format->{pattern}/) {
            $self->_saveFormat($format);
            my $matchcnt = 1;
            map { $format->{matches}->{$matchcnt++} = $_; } @matches;
printf "i matched format %s\n%s\n", $format->{'format_name'},
    Data::Dumper::Dumper($format);
            #print "pattern: ".$format->{'pattern'}."\n";
            #use Data::Dumper;
            #print Dumper(\@matches);
            my $nagiosSeverity = $format->{slots}->{severity} eq 'FATAL'    ? $self->{'tivoli_mapping'}->{'fatal'}    :
                                 $format->{slots}->{severity} eq 'CRITICAL' ? $self->{'tivoli_mapping'}->{'critical'} :
                                 $format->{slots}->{severity} eq 'SEVERE'   ? $self->{'tivoli_mapping'}->{'severe'}   :
                                 $format->{slots}->{severity} eq 'WARNING'  ? $self->{'tivoli_mapping'}->{'warning'}  :
                                 $format->{slots}->{severity} eq 'MINOR'    ? $self->{'tivoli_mapping'}->{'minor'}    :
                                 $format->{slots}->{severity} eq 'HARMLESS' ? $self->{'tivoli_mapping'}->{'harmless'} :
                                 $format->{slots}->{severity} eq 'UNKNOWN'  ? $self->{'tivoli_mapping'}->{'unknown'}  : 0;

            my $subject = $self->_substitutePrintf($format->{slots}->{'msg'}, $format->{'variables'}, $format->{'matches'});
        #    $subject    = $self->_substituteVariables($subject, \@matches);
	#    $self->_substituteSlots($format->{slots}, \@matches);
            $self->_substituteMatches($format);
printf "i matched format %s\n%s\n", $format->{'format_name'},
    Data::Dumper::Dumper($format);

die;
            $self->_restoreFormat($format);
            delete $format->{matches};
            return({
                'exit_code'   => $nagiosSeverity,
                'severity'    => uc $format->{severity},
                'format_name' => $format->{format_name},
#                'subject'     => $subject,
                'logline'     => $line,
		'slots'       => $format->{slots},
                  });
        }
    }
    return({
        'exit_code'   => $self->{'tivoli_mapping'}->{'harmless'},
        'severity'    => 'HARMLESS',
        'format_name' => 'NO MATCHING RULE',
        'subject'     => 'NO MATCHING RULE',
        'logline'     => $line,
	'slots'       => { },
          });
}



##############################################
# INTERNAL SUBS
##############################################

##############################################
# read a files content into a string and return it
sub _read {
    my $self     = shift;
    my $filename = shift;
    my $content;
    if(ref($filename) eq 'ARRAY') {
        for my $file (@{$filename}) {
            $content .= $self->_read($file);
        }
    } else {
        open(my $fh, '<', $filename) or croak("unable to read file $filename: $!");
        while(<$fh>) {
            $content .= $_;
        }
        close($fh);
    }
    return($content);
}

##############################################
# strips a string
sub _strip {
    my $self   = shift;
    my $string = shift;
    $string =~ s/^\s*//;
    $string =~ s/\s*$//;
    return($string);
}

##############################################
# parse the already read configstring
sub _parse {
    my $self = shift;

    $self->{'formatLookup'} = {};
    $self->{'formats'}      = [];

    my $formatDef;
    for my $line (split /\n/, $self->{'_formatstring'}) {
        $line = $self->_strip($line);
        next if $line =~ m/^\/\//;
        next if $line eq "";

        # new format definition begins
        if($line =~ m/^FORMAT/) {
            my($name,$follows, $followname) = $line =~ m/^FORMAT\s+(.*?)\s*(|FOLLOWS\s+(.*?))$/;
            if(defined $followname) {
                my @follows = split /\s*,\s*/, $followname;
                for my $follow (@follows) {
                    my $follow_format = $self->_getFormatByName($follow);
                    next if !defined $follow_format;
                    foreach my $attr (keys %{$follow_format}) {
                        next if $attr eq 'pattern'; # pattern will not be inherited
                        if($attr eq 'variables') {
                            $formatDef->{$attr} = $self->_mergeHash($formatDef->{$attr}, $follow_format->{$attr});
                        }
                        elsif ($attr eq 'slots') {
                            $formatDef->{$attr} = $self->_mergeHash($formatDef->{$attr}, $follow_format->{$attr});
                        }
                    }
                }
                $formatDef->{'follows'} = \@follows;
            }
            $formatDef->{'format_name'} = $name;
        }
        # new format definition ends
        elsif($line =~ m/^END/) {
            if(!defined $formatDef) {
                carp("found format end without beginning");
                return(1);
            }
            if(!defined $formatDef->{'pattern'}) {
                if(!exists $formatDef->{'follows'}) {
                    carp("found format without pattern");
                    return(1);
                }
            }

            $self->{'formatLookup'}->{$formatDef->{'format_name'}} = scalar @{$self->{'formats'}};
            #push @{$self->{'formats'}}, $formatDef;
            push @{$self->{'formats'}}, 
                Nagios::Tivoli::Config::Logfile::Format->new(
                    name => $formatDef->{format_name},
                    variables => $formatDef->{variables},
                    slots => $formatDef->{slots},
                    follows => $formatDef->{follows},
                    pattern => $formatDef->{pattern},
                );
            undef $formatDef;
        }

        # we are inside a format definition
        elsif(defined $formatDef) {
            # first line is the format
            if(!defined $formatDef->{'pattern'}) {
              # %s Specifies a variable string. 
              # %t Specifies a variable date of the form 'MMM DD hh:mm:ss'
              # %s+ Specifies one or more variable strings that 
              #     are separated by spaces. 
              # %s* Specifies zero or more strings separated by white space. 
              # %n Specifies a new line (CR).
              #    This applies only to the following adapters: 
              #    tecad_logfile_aix4-r1, tecad_logfile_hpux10,
              #    tecad_logfile_linux_ix86, tecad_logfile_linux-ppc, 
              #    tecad_logfile_linux-s390, tecad_logfile_solaris2,
              #    and tecad_win. 
                $formatDef->{'tiv_pattern'} = $line;
                $line =~ s/\\/\\\\/g;          # quote \
                $line =~ s/\(/\\(/g;           # quote (
                $line =~ s/\)/\\)/g;           # quote )
                $line =~ s/%\[\d+\]s/%s/g;     # replace %[2]s with just %s
                $line =~ s/\[/\\[/g;           # quote [
                $line =~ s/\]/\\]/g;           # quote ]
                $line =~ s/\?/\\?/g;           # quote ?
                $line =~ s/\|/\\|/g;           # quote |
                $line =~ s/\-/\\-/g;           # quote -
                $line =~ s/%s\+/\(.+?\)/g;     # %s+  becomes .+?
                $line =~ s/%s\*/\(.*?\)/g;     # %s*  becomes .*?
                $line =~ s/%s/\(\[^\\s\]+?\)/g;  # %s   becomes [^\s]+?
                #$line =~ s/%n/\\n/g;           # %n   becomes \n
                $line =~ s/%n//g;           # %n   becomes \n
                $line =~ s/%t/\(\\w\{3\}\\s+\\d\{1,2\}\\s+\\d\{1,2\}\:\\d\{1,2\}\:\\d\{1,2\}\)/g;
                $formatDef->{'pattern'} = $line;
            }

            # lines starting with - are variables
            elsif($line =~ m/^-(.*?)\s+(.*)$/i) {
                $formatDef->{'variables'}->{$1} = $2;
            }

            # normal definitions
            elsif($line =~ m/^(.*?)\s+"*(.*?)"*\s*$/) {
                $formatDef->{'slots'}->{$1} = $2;
            }
        }

        else {
            carp("line: '".$line."' is outside of a format definition");
            return(1);
        }
    }

    return(0);
}

sub _saveFormat {
  my $self = shift;
  my $format = shift;
  delete $format->{saved_slots};
  foreach (keys %{$format->{slots}}) {
    $format->{saved_slots}->{$_} = $format->{slots}->{$_};
  }
  delete $format->{saved_variables};
  foreach (keys %{$format->{variables}}) {
    $format->{saved_variables}->{$_} = $format->{variables}->{$_};
  }
}

sub _restoreFormat {
  my $self = shift;
  my $format = shift;
  delete $format->{slots};
  foreach (keys %{$format->{saved_slots}}) {
    $format->{slots}->{$_} = $format->{saved_slots}->{$_};
  }
  delete $format->{variables};
  foreach (keys %{$format->{saved_variables}}) {
    $format->{variables}->{$_} = $format->{saved_variables}->{$_};
  }
}

##############################################
# replaces matchvars in internal variables and slots
# replaces reserved keywords in slots
# adapter_host LABEL
# date $4
# -V1 $1

sub _substituteMatches {
  my $self = shift;
  my $format = shift;
  foreach my $slot (keys %{$format->{slots}}) {
    if ($format->{slots}->{$slot} =~ /^\$(\d+)/) {
      if (defined $format->{matches}->{$1}) {
        $format->{slots}->{$slot} = $format->{matches}->{$1};
      } else {
        printf STDERR "cannot replace \$%d in slot %s\n", $1, $slot;
      }
    } elsif ($format->{slots}->{$_} eq 'DEFAULT') {
      if ($_ eq 'hostname') {
        $format->{slots}->{$_} = $self->{format_mappings}->{hostname};
      } elsif ($_ eq 'fqhostname') {
        $format->{slots}->{$_} = $self->{format_mappings}->{fqhostname};
      } elsif ($_ eq 'origin') {
        $format->{slots}->{$_} = $self->{format_mappings}->{origin};
      } else {
        $format->{slots}->{$_} = 'check_logfiles';
      }
    } elsif ($format->{slots}->{$_} eq 'LABEL') {
      $format->{slots}->{$_} = $self->{format_mappings}->{LABEL};
    } elsif ($format->{slots}->{$_} eq 'FILENAME') {
      $format->{slots}->{$_} = $self->{format_mappings}->{FILENAME};
    }
  }
  foreach my $var (keys %{$format->{variables}}) {
    if ($format->{variables}->{$var} =~ /^\$(\d+)/) {
      if (defined $format->{matches}->{$1}) {
        $format->{variables}->{$var} = $format->{matches}->{$1};
      } else {
        printf STDERR "cannot replace \$%d in var %s\n", $1, $var;
      }
    }
  }
}

##############################################
# evals a printf message with given variables
sub _substitutePrintf {
    my $self      = shift;
    my $msg       = shift;
    my $variables = shift;
    my $matches   = shift;

    return $msg if $msg !~ m/^PRINTF/i;

    my @printf = $msg =~ m/printf\("(.*?)"\s*,\s*(.*)\)/i;
    my @replacements;
    for my $key (split /\s*,\s*/, $printf[1]) {
        if(defined $variables->{$key}) {
            my($nr) = $variables->{$key} =~ m/\$(\d+)/;
            $nr--;
            push @replacements,  $matches->[$nr];
        } else {
            print "$key not found\n";
            push @replacements,  '';
        }
    }
    my $replaced = $msg;
    eval {
        $replaced = sprintf($printf[0], @replacements);
    };
    return($replaced);
}

##############################################
# replaces variables in messages
sub _substituteVariables {
    my $self      = shift;
    my $msg       = shift;
    my $matches   = shift;
    #use Data::Dumper;
    #print "---------------------\n";
    #print Dumper($msg);
    #print Dumper($matches);

    my @vars = $msg =~ m/\$(\d)/ig;
    for my $nr (@vars) {
        my $replace = '';
        my $key = $nr - 1;
        if(defined $matches->[$key]) {
            $replace = $matches->[$key];
        } else {
            print "$nr not found\n";
        }
        print STDERR "replacing $nr with $replace\n";
        $msg =~ s/\$$nr/$replace/g;
    }
    return($msg);
}

##############################################
# merges two hashes
sub _mergeHash {
    my $self  = shift;
    my $hash1 = shift;
    my $hash2 = shift;

    for my $key (keys %{$hash2}) {
        #$hash1->{lc $key} = $hash2->{$key};
        $hash1->{$key} = $hash2->{$key};
    }
    return($hash1);
}

##############################################
# returns a format definition by name
sub _getFormatByName {
    my $self  = shift;
    my $name  = shift;

    return if !defined $self->{'formatLookup'}->{$name};
    my $nr = $self->{'formatLookup'}->{$name};
    return($self->{'formats'}->[$nr]);
}


package Nagios::Tivoli::Config::Logfile::Format;


use strict;
use warnings;
use Carp;
use vars qw(@ISA);

@ISA = qw(Nagios::Tivoli::Config::Logfile);

{
  our $formats = {};
  
  sub add_format {
    my $format = shift;
    $formats->{$format->{name}} = $format;
  }

  sub getFormatByName {
    my $name = shift;
    return exists $formats->{$name} ? $formats->{$name} : undef;
  }
}

sub new {
  my($this, $param ) = @_;
  my $class = ref($this) || $this;

  my $self = {
      name => '',
      slots => {},
      variables => {},
  };
  bless $self, $class;

  if (ref($param) eq "HASH") {
    for my $key (keys %{$param}) {
      if (!defined $self->{lc $key}) {
        carp("unrecognized parameter: $key");
      } else {
        if (ref($param->{$key}) eq 'HASH') {
          $self->_mergeHash($self->{$key}, $param->{$key});
        } else {
          $self->{lc $key} = $param->{$key};
        }
      }
    }
  }
  if(!defined $self->{name}) [
    croak("please either specify formatfile or formatstring");
  }
  return $self;
}

1;
